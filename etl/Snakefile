import os
import subprocess
import shutil
from typing import List

import geopandas
import pandas

from scripts.helpers import hazard_layer_name_formatted, generate_final_hazard_layer_names


# Example config
# - override by running:
#    snakemake --cores=1 --configfile=config_local.yml all
configfile: "config.yml"


# Read further configuration data from CSV
hazard_layers = pandas.read_csv(config["hazard_layers"])
# output_layers = generate_final_hazard_layer_names(hazard_layers)


wildcard_constraints:
    layer="[^/]+",
    # layer_fmt="\w+__rp_[\d]__rcp_[\d]__epoch_[\d]__conf_[\d]",

# Run all file-base jobs, after load_to_database
rule all:
    input:
        expand("../tileserver/raster/data/{layer}.tif", layer=hazard_layers.key),

rule raster_temp_file:
    output:
        "raster/link/{layer}.tif",
    run:
        layer = get_hazard_layer(wildcards.layer, hazard_layers)
        # This symlink just does not want to work
        # os.symlink(os.path.join(config["analysis_data_dir"], "processed_data", layer.path), str(output))
        shutil.copyfile(
            os.path.join(config["analysis_data_dir"], "processed_data", layer.path),
            str(output)
        )

def get_hazard_layer(layer_name, hazard_layers):
    try:
        print ("getting hazard layer: ", layer_name)
        return hazard_layers[hazard_layers.key == layer_name].iloc[0]
    except IndexError as e:
        print(f"Could not find {layer_name} in hazard layers.")
        raise e
    finally:
        print ("got hazard layer")

rule raster_zero_nodata:
    input:
        rules.raster_temp_file.output,
    output:
        "raster/nodata/{layer}.tif",
    shell:
        """
        NODATA=$(gdalinfo "{input}" -json | jq .bands[0].noDataValue)

        # handle case of NODATA == nan - the JSON output of gdalinfo will change
        # nan to "NaN" so we need to reverse that for gdal_calc.py
        if [ "$NODATA" == '"NaN"' ]
        then
          NODATA=nan
        fi

        if [ "$NODATA" == 'null' ]
        then
          NODATA=nan
        fi

        # replace zeros with NoData value
        gdal_calc.py \
          --quiet \
          -A "{input}" \
          --outfile="{output}" \
          --overwrite \
          --calc="numpy.where(A<=0,$NODATA,A)" \
          --NoDataValue=$NODATA \
          --hideNoData
        """

rule raster_clip_ns:
    input:
        rules.raster_zero_nodata.output,
    output:
        "raster/clip/{layer}.tif",
    shell:
        """
        gdal_translate -projwin -173.881360209 84.039535351 177.393420678 -84.78788384 -of GTiff {input} {output}
        """

rule raster_to_cog:
    input:
        rules.raster_clip_ns.output,
    output:
        "../tileserver/raster/data/{layer}.tif",
    shell:
        """
        # translate to Cloud-Optimised GeoTIFF
        #
        # could use gdalwarp directly - options chosen to match (reasonably
        # closely) the output of `terracotta optimize-rasters`:
        #
        # gdalwarp "{input}" "{output}" \
        #     -t_srs "EPSG:3857" \
        #     -r near \
        #     -of COG \
        #     -co COMPRESS=DEFLATE \
        #     -co BLOCKSIZE=256
        #
        terracotta optimize-rasters \
            -o ../tileserver/raster/data/ \
            --overwrite \
            --reproject \
            --nproc -1 \
            --resampling-method nearest \
            {input}
        """

# rule raster_rename:
#     input:
#         rules.raster_to_cog.output,
#     output:
#         "../tileserver/raster/data/{layer}.tif",
#     run:
#         layer_name_formatted = hazard_layer_name_formatted(wildcards.layer, hazard_layers)
#         print ("HELLO", config["raster_processing_data_dir"], wildcards.layer)
#         in_file = os.path.join(
#             config["raster_processing_data_dir"],
#             "cog",
#             "{layer}.tif".format(layer=wildcards.layer)
#         )
#         out_file = os.path.join(
#             config["raster_output_dir"],
#             layer_name_formatted
#         )
#         print ("Input: ", in_file)
#         print ("Output: ", out_file)
#         shutil.move(
#             in_file,
#             out_file
#         )